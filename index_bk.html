<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #111;
    --fg: #e8e8e8;
    --muted: #b3b3b3;
    --card: #1a1a1a;
    --accent: #4da3ff;
    --border: #2a2a2a;
    --danger: #ff5a5a;
    --ok: #3ccf7a;
    --control-bg: #151515;
    --control-fg: #e8e8e8;
    --focus: 0 0 0 3px rgba(77,163,255,0.35);
  }
  .theme-light {
    --bg: #ffffff;
    --fg: #1d1d1f;
    --muted: #555;
    --card: #f5f5f7;
    --accent: #1f6feb;
    --border: #e5e5ea;
    --danger: #d7263d;
    --ok: #228b22;
    --control-bg: #fff;
    --control-fg: #1d1d1f;
    --focus: 0 0 0 3px rgba(31,111,235,0.25);
  }

  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    line-height: 1.4;
  }

  .container {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    padding: 12px;
    max-width: 1100px;
    margin: 0 auto;
  }

  /* Card rows */
  .row {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
  }

  .row-title {
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--muted);
    margin: 0 0 10px 0;
  }

  .phrases {
    display: grid;
    grid-template-columns: 1fr;
    gap: 6px;
  }
  .phrase-line {
    display: grid;
    grid-template-columns: 30px 1fr 28px;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: var(--control-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
  }
  .lang-tag {
    font-weight: 600;
    color: var(--muted);
    text-align: center;
    user-select: none;
  }
  .phrase-text {
    font-size: clamp(14px, var(--phrase-font, 26px), 100px);
    white-space: normal;
    word-wrap: break-word;
  }
  .replay-btn {
    width: 28px; height: 28px; border-radius: 6px;
    display: inline-grid; place-items: center;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--fg);
    cursor: pointer;
  }
  .replay-btn:focus { outline: none; box-shadow: var(--focus); }
  .replay-btn:hover { background: rgba(255,255,255,0.06); }

  /* Inline compact controls */
  .inline-controls {
    display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
  }
  .inline-controls .spacer { flex: 1; }

  select, input[type="text"], input[type="number"], input[type="file"] {
    background: var(--control-bg);
    color: var(--control-fg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 8px;
    font-size: 14px;
  }
  /* Combo boxes compact width, adapt to content */
  select { width: auto; max-width: 100%; }

  button {
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 14px;
    cursor: pointer;
  }
  button:disabled { opacity: 0.6; cursor: not-allowed; }
  button.secondary {
    background: transparent; color: var(--fg);
    border: 1px solid var(--border);
  }
  button:focus { outline: none; box-shadow: var(--focus); }

  /* Panels inside rows */
  .panel {
    border: 1px dashed var(--border);
    border-radius: 10px;
    padding: 10px;
    margin-top: 8px;
  }
  .panel-title {
    font-weight: 600;
    color: var(--muted);
    margin-bottom: 8px;
  }
  .checks {
    display: grid;
    grid-template-columns: repeat(4, minmax(60px, auto));
    gap: 8px 14px;
    align-items: center;
  }
  .check {
    display: inline-flex; align-items: center; gap: 6px;
  }
  input[type="checkbox"] { width: 18px; height: 18px; }

  .font-slider {
    display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  }
  input[type="range"] { width: 180px; }

  .tiny-toggle {
    display: inline-flex; gap: 6px; align-items: center;
    font-size: 13px;
  }
  .badge {
    display: inline-flex; align-items: center; gap: 6px;
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 5px 10px;
    color: var(--muted);
  }

  .textarea {
    width: 100%;
    min-height: 160px;
    max-height: 380px;
    background: var(--control-bg);
    color: var(--control-fg);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 13px;
    line-height: 1.5;
    resize: vertical;
  }

  .progress-line {
    display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
  }
  progress {
    width: 220px; height: 14px;
    accent-color: var(--accent);
  }
  .status {
    font-size: 13px; color: var(--muted);
  }
  .status.ok { color: var(--ok); }
  .status.error { color: var(--danger); }

  /* Mobile-first spacing and tap targets */
  .inline-controls > * { min-height: 40px; }
  .checks input[type="checkbox"] { width: 22px; height: 22px; }

  /* Responsive layout */
  @media (min-width: 900px) {
    .container { gap: 14px; padding: 16px; }
  }
  @media (max-width: 600px) {
    .checks { grid-template-columns: 1fr; }
    .phrases { gap: 8px; }
    .phrase-line { grid-template-columns: 28px 1fr 28px; }
    .inline-controls { flex-direction: column; align-items: stretch; }
    .inline-controls .spacer { display: none; }
    select, input[type="number"], input[type="text"], button { width: 100%; }
    input[type="range"] { width: 100%; }
  }
</style>
</head>
<body class="theme-dark">
  <div class="container">

    <!-- Row 1: Current phrases display -->
    <section class="row" id="row-phrases">
      <div class="phrases" id="phrasesView">
        <!-- ES -->
        <div class="phrase-line" data-lang="es">
          <div class="lang-tag">ES</div>
          <div class="phrase-text" id="text-es"></div>
          <button class="replay-btn" id="replay-es" title="Reproducir ES" aria-label="Replay ES">▶</button>
        </div>
        <!-- EN -->
        <div class="phrase-line" data-lang="en">
          <div class="lang-tag">EN</div>
          <div class="phrase-text" id="text-en"></div>
          <button class="replay-btn" id="replay-en" title="Play EN" aria-label="Replay EN">▶</button>
        </div>
        <!-- IT -->
        <div class="phrase-line" data-lang="it">
          <div class="lang-tag">IT</div>
          <div class="phrase-text" id="text-it"></div>
          <button class="replay-btn" id="replay-it" title="Riproduci IT" aria-label="Replay IT">▶</button>
        </div>
        <!-- PT -->
        <div class="phrase-line" data-lang="pt">
          <div class="lang-tag">PT</div>
          <div class="phrase-text" id="text-pt"></div>
          <button class="replay-btn" id="replay-pt" title="Reproduzir PT" aria-label="Replay PT">▶</button>
        </div>
      </div>
    </section>

    <!-- Row 2: Operation Modes -->
    <section class="row" id="row-modes">
      <div class="inline-controls">
        <label class="badge">
          <span>Mode</span>
          <select id="modeSelect" aria-label="Mode">
            <option>Manual Mode</option>
            <option>Auto Mode</option>
            <option>Speaking Practice Mode</option>
            <option>Writing Practice Mode</option>
          </select>
        </label>
        <button id="btnRandom" class="secondary" title="Show a random phrase">Random Phrase</button>
        <div class="spacer"></div>
        <div id="modeContent" style="width:100%"></div>
      </div>
    </section>

    <!-- Row 3: Language Reading Checkboxes -->
    <section class="row" id="row-read">
      <div class="panel">
        <div class="panel-title">Read Language</div>
        <div class="checks">
          <label class="check"><input type="checkbox" id="read-es" checked /> <span>ES</span></label>
          <label class="check"><input type="checkbox" id="read-en" /> <span>EN</span></label>
          <label class="check"><input type="checkbox" id="read-it" checked /> <span>IT</span></label>
          <label class="check"><input type="checkbox" id="read-pt" /> <span>PT</span></label>
        </div>
      </div>
    </section>

    <!-- Row 3 (continued): Language Display Options -->
    <section class="row" id="row-show">
      <div class="panel">
        <div class="panel-title">Show Language</div>
        <div class="checks">
          <label class="check"><input type="checkbox" id="show-es" checked /> <span>ES</span></label>
          <label class="check"><input type="checkbox" id="show-en" /> <span>EN</span></label>
          <label class="check"><input type="checkbox" id="show-it" checked /> <span>IT</span></label>
          <label class="check"><input type="checkbox" id="show-pt" /> <span>PT</span></label>
        </div>
        <div class="font-slider" style="margin-top:10px">
          <span class="badge">Font size</span>
          <input type="range" min="14" max="100" value="26" id="fontRange" />
          <span id="fontValue" class="status">26 px</span>
          <span class="spacer"></span>
          <label class="tiny-toggle">
            <input type="checkbox" id="themeToggle" checked />
            <span>Dark theme</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Row 4: Phrase list (CSV textbox) -->
    <section class="row" id="row-csv">
      <div class="row-title">Phrases (CSV: ES,EN,IT,PT)</div>
      <textarea class="textarea" id="csvBox"></textarea>
    </section>

    <!-- Row 5: Phrases Loading Options -->
    <section class="row" id="row-load">
      <div class="inline-controls">
        <label class="badge">
          <span>Predefined sets</span>
          <select id="predefinedSelect">
            <option value="">(Select a set)</option>
          </select>
        </label>
        <button id="btnLoadPredefined" class="secondary">Load selected</button>
        <div class="spacer"></div>
        <label class="badge">
          <span>Load from file</span>
          <input type="file" id="fileInput" accept=".csv,.txt" />
        </label>
      </div>
    </section>

    <!-- Row 6: Speech Synthesis configurations -->
    <section class="row" id="row-tts">
      <div class="inline-controls" style="gap:10px; flex-wrap:wrap">
        <label class="badge"><span>ES Voice</span>
          <select id="voice-es"></select>
        </label>
        <label class="badge"><span>EN Voice</span>
          <select id="voice-en"></select>
        </label>
        <label class="badge"><span>IT Voice</span>
          <select id="voice-it"></select>
        </label>
        <label class="badge"><span>PT Voice</span>
          <select id="voice-pt"></select>
        </label>
        <label class="badge"><span>Rate</span>
          <input type="number" id="rate" min="0.5" max="2" step="0.1" value="1.0" style="width:80px" />
        </label>
        <label class="badge"><span>Pitch</span>
          <input type="number" id="pitch" min="0" max="2" step="0.1" value="1.0" style="width:80px" />
        </label>
      </div>
    </section>
  </div>

<script>
(() => {
  // --- State ---
  const els = {
    text: {
      es: document.getElementById('text-es'),
      en: document.getElementById('text-en'),
      it: document.getElementById('text-it'),
      pt: document.getElementById('text-pt'),
    },
    replay: {
      es: document.getElementById('replay-es'),
      en: document.getElementById('replay-en'),
      it: document.getElementById('replay-it'),
      pt: document.getElementById('replay-pt'),
    },
    read: {
      es: document.getElementById('read-es'),
      en: document.getElementById('read-en'),
      it: document.getElementById('read-it'),
      pt: document.getElementById('read-pt'),
    },
    show: {
      es: document.getElementById('show-es'),
      en: document.getElementById('show-en'),
      it: document.getElementById('show-it'),
      pt: document.getElementById('show-pt'),
    },
    modeSelect: document.getElementById('modeSelect'),
    btnRandom: document.getElementById('btnRandom'),
    modeContent: document.getElementById('modeContent'),
    csvBox: document.getElementById('csvBox'),
    predefinedSelect: document.getElementById('predefinedSelect'),
    btnLoadPredefined: document.getElementById('btnLoadPredefined'),
    fileInput: document.getElementById('fileInput'),
    fontRange: document.getElementById('fontRange'),
    fontValue: document.getElementById('fontValue'),
    themeToggle: document.getElementById('themeToggle'),
    voices: {
      es: document.getElementById('voice-es'),
      en: document.getElementById('voice-en'),
      it: document.getElementById('voice-it'),
      pt: document.getElementById('voice-pt'),
    },
    rate: document.getElementById('rate'),
    pitch: document.getElementById('pitch'),
  };

  const langs = ['es','en','it','pt'];
  const langMeta = {
    es: { localeGuess: ['es-ES','es-419','es-MX','es-AR','es-PE'], label: 'ES' },
    en: { localeGuess: ['en-US','en-GB','en-AU'], label: 'EN' },
    it: { localeGuess: ['it-IT'], label: 'IT' },
    pt: { localeGuess: ['pt-BR','pt-PT'], label: 'PT' },
  };
	//fr: { localeGuess: ['fr-FR','fr-CA','fr-BE','fr-CH'], label: 'FR' },
	//de: { localeGuess: ['de-DE','de-AT','de-CH'], label: 'DE' }
  

  let parsedRows = [];               // Array of {es,en,it,pt}
  let currentIndex = -1;             // Index in parsedRows
  let phraseSessionId = 0;           // Monotonic token
  let autoTimer = null;              // Auto mode interval
  let speakingPractice = {
    active: false,
    rec: null,
    lang: 'es',
    min: 90,
    liveTextEl: null,
    scoreEl: null,
    progressEl: null,
    statusEl: null,
  };
  let writingPractice = {
    active: false,
    lang: 'es',
    inputEl: null,
    statusEl: null,
    writingBusy: false,
    currentWriteTarget: '',
  };

  // --- Utilities ---
  function normalizeForCompare(s) {
    return (s || '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // strip diacritics
      .replace(/[^\p{L}\p{N}\s]/gu, ' ')               // remove punctuation
      .replace(/\s+/g, ' ')                            // collapse spaces
      .trim();
  }

  function levenshtein(a, b) {
    const m = a.length, n = b.length;
    if (m === 0) return n;
    if (n === 0) return m;
    const v0 = new Array(n + 1);
    const v1 = new Array(n + 1);
    for (let i = 0; i <= n; i++) v0[i] = i;
    for (let i = 0; i < m; i++) {
      v1[0] = i + 1;
      const ai = a.charCodeAt(i);
      for (let j = 0; j < n; j++) {
        const cost = ai === b.charCodeAt(j) ? 0 : 1;
        v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
      }
      for (let j = 0; j <= n; j++) v0[j] = v1[j];
    }
    return v0[n];
  }

  function similarityPercent(a, b) {
    const A = normalizeForCompare(a);
    const B = normalizeForCompare(b);
    if (!A && !B) return 100;
    const dist = levenshtein(A, B);
    const base = Math.max(A.length, B.length);
    const pct = Math.max(0, Math.round((1 - dist / base) * 100));
    return pct;
  }

  function parseCSV(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
    const rows = [];
    for (const line of lines) {
      const cols = parseCSVLine(line);
      if (cols.length >= 4) {
        rows.push({ es: cols[0], en: cols[1], it: cols[2], pt: cols[3] });
      }
    }
    return rows;
  }

  // Basic CSV line parser supporting double-quoted fields and escaped quotes "".
  function parseCSVLine(line) {
    const out = [];
    let cur = '';
    let inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (inQ) {
        if (ch === '"') {
          if (i + 1 < line.length && line[i + 1] === '"') {
            cur += '"'; i++;
          } else {
            inQ = false;
          }
        } else {
          cur += ch;
        }
      } else {
        if (ch === ';') {
          out.push(cur); cur = '';
        } else if (ch === '"') {
          inQ = true;
        } else {
          cur += ch;
        }
      }
    }
    out.push(cur);
    return out.map(s => s.trim());
  }

  function pickRandomIndex(len) {
    return len > 0 ? Math.floor(Math.random() * len) : -1;
  }

  function applyShowVisibility() {
    for (const k of langs) {
      const show = els.show[k].checked;
      document.querySelector(`.phrase-line[data-lang="${k}"]`).style.display = show ? 'grid' : 'none';
    }
  }

  function setPhraseTexts(row) {
    els.text.es.textContent = row?.es || '';
    els.text.en.textContent = row?.en || '';
    els.text.it.textContent = row?.it || '';
    els.text.pt.textContent = row?.pt || '';
  }

  function getReadOrder() {
    return ['es','en','it','pt']; // fixed order
  }

  function getVoicesMap() {
    return {
      es: els.voices.es.value || '',
      en: els.voices.en.value || '',
      it: els.voices.it.value || '',
      pt: els.voices.pt.value || '',
    };
  }

  function getRatePitch() {
    return {
      rate: Math.max(0.5, Math.min(2, parseFloat(els.rate.value || '1') || 1)),
      pitch: Math.max(0, Math.min(2, parseFloat(els.pitch.value || '1') || 1)),
    };
  }

  // --- Speech Synthesis: robust sequence with session token and timeouts ---
  async function speakCurrentRowSequence(sessionToken, row) {
    // Gather settings
    const readLangs = {
      es: els.read.es.checked,
      en: els.read.en.checked,
      it: els.read.it.checked,
      pt: els.read.pt.checked,
    };
    const any = Object.values(readLangs).some(Boolean);
    if (!any) return; // resolve immediately

    // Wait for voices to be ready (up to 1000ms)
    await new Promise(res => {
      const start = performance.now();
      const done = () => res();
      const tryNow = () => {
        if (speechSynthesis.getVoices().length > 0 || performance.now() - start > 1000) {
          done();
        } else {
          setTimeout(tryNow, 100);
        }
      };
      if ('onvoiceschanged' in speechSynthesis) {
        let fired = false;
        const handler = () => { if (!fired) { fired = true; speechSynthesis.onvoiceschanged = null; done(); } };
        speechSynthesis.onvoiceschanged = handler;
        setTimeout(() => { if (!fired) { speechSynthesis.onvoiceschanged = null; done(); } }, 1000);
      } else {
        tryNow();
      }
    });

    // Cancel anything pending, then enqueue sequence
    try { speechSynthesis.cancel(); } catch {}

    const voices = speechSynthesis.getVoices();
    const voiceIds = getVoicesMap();
    const { rate, pitch } = getRatePitch();
    const order = getReadOrder().filter(k => readLangs[k]);

    let totalChars = 0;
    const utters = [];
    for (const k of order) {
      const text = (row && row[k]) ? String(row[k]) : '';
      totalChars += text.length;
      const u = new SpeechSynthesisUtterance(text);
      const v = voices.find(v => (v.name === voiceIds[k]) || (v.lang && langMeta[k].localeGuess.some(gl => v.lang.startsWith(gl.slice(0,2)))));
      if (v) u.voice = v;
      u.lang = (v && v.lang) ? v.lang : langMeta[k].localeGuess[0];
      u.rate = rate;
      u.pitch = pitch;
      utters.push({ k, u });
    }

    let endedCount = 0;
    let resolved = false;

    const finishResolve = () => {
      if (resolved) return;
      resolved = true;
      // no return (Promise resolved by outer async)
    };

    const hardTimeoutMs = Math.max(12000, 12000 + Math.ceil(totalChars / 100) * 2000);
    const hardTimer = setTimeout(() => {
      if (document.hidden) {
        try { speechSynthesis.cancel(); } catch {}
        finishResolve();
      } else {
        try { speechSynthesis.cancel(); } catch {}
        finishResolve();
      }
    }, hardTimeoutMs);

    // Poll speaking becomes false for >=300ms before resolve
    let lastSpeakingFalse = null;
    const poll = setInterval(() => {
      if (resolved) { clearInterval(poll); return; }
      if (!speechSynthesis.speaking) {
        if (lastSpeakingFalse == null) lastSpeakingFalse = performance.now();
        if (performance.now() - lastSpeakingFalse >= 300) {
          clearInterval(poll);
          clearTimeout(hardTimer);
          finishResolve();
        }
      } else {
        lastSpeakingFalse = null;
      }
    }, 100);

    await new Promise(resolve => {
      // Attach handlers and speak sequentially (enqueue lets them play in order)
      for (const { u } of utters) {
        u.onend = () => {
          if (resolved) return;
          if (sessionToken !== phraseSessionId) return;
          endedCount++;
          if (endedCount === utters.length) {
            // Let poll/300ms rule finalize; if nothing fires, poll will resolve
          }
        };
        u.onerror = () => {
          if (resolved) return;
          if (sessionToken !== phraseSessionId) return;
          endedCount++;
          // keep going; if all error/end, poll/timeout will settle
        };
        speechSynthesis.speak(u);
      }
      // The resolution is managed by polling + hard timeout; to "await" until resolve:
      const watcher = setInterval(() => {
        if (resolved) {
          clearInterval(watcher);
          clearInterval(poll);
          clearTimeout(hardTimer);
          resolve();
        }
      }, 50);
    });
  }

  // Single-language replay (row scope only)
  function replayLanguage(k) {
    if (currentIndex < 0 || !parsedRows[currentIndex]) return;
    const sessionToken = ++phraseSessionId;
    try { speechSynthesis.cancel(); } catch {}
    const row = parsedRows[currentIndex];
    const text = row[k] || '';
    const vmap = getVoicesMap();
    const voices = speechSynthesis.getVoices();
    const v = voices.find(v => v.name === vmap[k]) || voices.find(v => v.lang && v.lang.startsWith(langMeta[k].localeGuess[0].slice(0,2)));
    const u = new SpeechSynthesisUtterance(text);
    if (v) u.voice = v;
    u.lang = (v && v.lang) ? v.lang : langMeta[k].localeGuess[0];
    const { rate, pitch } = getRatePitch();
    u.rate = rate; u.pitch = pitch;
    speechSynthesis.speak(u);
  }

  // --- Selection & Display ---
  function ensureParsed() {
    parsedRows = parseCSV(els.csvBox.value);
  }

  function selectAndShowRandomRow({ speak = true } = {}) {
    ensureParsed();
    if (!parsedRows.length) return Promise.resolve();
    currentIndex = pickRandomIndex(parsedRows.length);
    const row = parsedRows[currentIndex];
    setPhraseTexts(row);
    applyShowVisibility();
    const sessionToken = ++phraseSessionId;
    if (speak) {
      return speakCurrentRowSequence(sessionToken, row);
    }
    return Promise.resolve();
  }

  // --- Modes UI ---
  function renderModePanel() {
    const m = els.modeSelect.value;
    els.modeContent.innerHTML = '';
    if (m === 'Manual Mode') {
      const div = document.createElement('div');
      div.className = 'panel';
      
    } else if (m === 'Auto Mode') {
      const div = document.createElement('div');
      div.className = 'panel';
      div.innerHTML = `
        <div class="panel-title">Automatic rotation</div>
        <div class="inline-controls">
          <label class="badge"><span>Interval (s)</span>
            <input id="autoInterval" type="number" min="2" step="1" value="5" style="width:90px" />
          </label>
          <button id="autoStart">Start</button>
          <button id="autoStop" class="secondary">Stop</button>
          <span id="autoStatus" class="status">Stopped</span>
        </div>
      `;
      els.modeContent.appendChild(div);
      const autoStatus = div.querySelector('#autoStatus');
      const autoStart = () => {
        const sec = Math.max(1, parseInt(div.querySelector('#autoInterval').value || '5', 10));
        if (autoTimer) clearInterval(autoTimer);
        autoStatus.textContent = 'Running…';
        selectAndShowRandomRow({ speak: true });
        autoTimer = setInterval(() => {
          const token = ++phraseSessionId;
          // cancel previous speech before next cycle
          try { speechSynthesis.cancel(); } catch {}
          selectAndShowRandomRow({ speak: true });
        }, sec * 1000);
      };
      const autoStop = () => {
        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        autoStatus.textContent = 'Stopped';
      };
      div.querySelector('#autoStart').onclick = autoStart;
      div.querySelector('#autoStop').onclick = autoStop;
    } else if (m === 'Speaking Practice Mode') {
      const div = document.createElement('div');
      div.className = 'panel';
      div.innerHTML = `
        <div class="panel-title">Speaking practice</div>
        <div class="inline-controls">
          <label class="badge"><span>Practice language</span>
            <select id="sp-lang">
              <option value="es">ES</option>
              <option value="en">EN</option>
              <option value="it">IT</option>
              <option value="pt">PT</option>
            </select>
          </label>
          <label class="badge"><span>Min similarity %</span>
            <input id="sp-min" type="number" min="50" max="100" step="1" value="90" style="width:90px" />
          </label>
          <button id="sp-start">Start</button>
          <button id="sp-stop" class="secondary">Stop</button>
          <span id="sp-status" class="status">Idle</span>
        </div>
        <div class="panel" style="margin-top:10px">
          <div class="panel-title">Live transcription</div>
          <div class="progress-line">
            <progress id="sp-progress" value="0" max="100"></progress>
            <span id="sp-score" class="status">0%</span>
          </div>
          <div id="sp-live" class="status" style="margin-top:8px; font-size:15px;"></div>
        </div>
      `;
      els.modeContent.appendChild(div);

      speakingPractice.liveTextEl = div.querySelector('#sp-live');
      speakingPractice.progressEl = div.querySelector('#sp-progress');
      speakingPractice.scoreEl = div.querySelector('#sp-score');
      speakingPractice.statusEl = div.querySelector('#sp-status');

      div.querySelector('#sp-start').onclick = startSpeakingPractice;
      div.querySelector('#sp-stop').onclick = stopSpeakingPractice;
      div.querySelector('#sp-lang').onchange = e => { speakingPractice.lang = e.target.value; };
      div.querySelector('#sp-min').oninput = e => { speakingPractice.min = Math.max(50, Math.min(100, parseInt(e.target.value || '90', 10))); };
    } else if (m === 'Writing Practice Mode') {
      const div = document.createElement('div');
      div.className = 'panel';
      div.innerHTML = `
        <div class="panel-title">Writing practice</div>
        <div class="inline-controls">
          <label class="badge"><span>Practice language</span>
            <select id="wr-lang">
              <option value="es">ES</option>
              <option value="en">EN</option>
              <option value="it">IT</option>
              <option value="pt">PT</option>
            </select>
          </label>
          <button id="wr-start">Start</button>
          <button id="wr-stop" class="secondary">Stop</button>
          <span id="wr-status" class="status">Idle</span>
        </div>
        <div class="panel" style="margin-top:10px">
          <div class="panel-title">Type the phrase</div>
          <input id="wr-input" type="text" placeholder="Type here…" style="width: 100%" />
        </div>
      `;
      els.modeContent.appendChild(div);

      writingPractice.inputEl = div.querySelector('#wr-input');
      writingPractice.statusEl = div.querySelector('#wr-status');

      div.querySelector('#wr-start').onclick = startWritingPractice;
      div.querySelector('#wr-stop').onclick = stopWritingPractice;
      div.querySelector('#wr-lang').onchange = e => { writingPractice.lang = e.target.value; };
    }
  }

  // --- Speaking Practice Flow ---
  function createRecognition(lang) {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return null;
    const rec = new SR();
    rec.lang = pickRecLang(lang);
    rec.continuous = true;
    rec.interimResults = true;
    rec.maxAlternatives = 1;
    return rec;
  }

  function pickRecLang(k) {
    // Use first locale guess for recognition; browsers may map internally
    return langMeta[k].localeGuess[0] || 'en-US';
  }

  async function startSpeakingPractice() {
    if (speakingPractice.active) return;
    speakingPractice.active = true;
    speakingPractice.lang = (els.modeContent.querySelector('#sp-lang')?.value) || 'es';
    speakingPractice.min = parseInt(els.modeContent.querySelector('#sp-min')?.value || '90', 10) || 90;
    speakingPractice.statusEl.textContent = 'Starting…';

    // User gesture initiates: select phrase and speak sequence, then start mic
    await selectAndShowRandomRow({ speak: true });
    if (!speakingPractice.active) return;

    const target = (parsedRows[currentIndex] || {})[speakingPractice.lang] || '';
    const myToken = phraseSessionId;

    if (speakingPractice.rec) {
      try { speakingPractice.rec.abort(); } catch {}
      speakingPractice.rec = null;
    }
    const rec = createRecognition(speakingPractice.lang);
    speakingPractice.rec = rec;

    if (!rec) {
      speakingPractice.statusEl.textContent = 'Speech recognition not supported in this browser.';
      speakingPractice.active = false;
      return;
    }

    speakingPractice.liveTextEl.textContent = '';
    speakingPractice.progressEl.value = 0;
    speakingPractice.scoreEl.textContent = '0%';
    speakingPractice.statusEl.textContent = 'Listening…';

    rec.onresult = (e) => {
      if (!speakingPractice.active) return;
      if (myToken !== phraseSessionId) return;
      let interim = '';
      let finalText = '';
      for (let i = e.resultIndex; i < e.results.length; i++) {
        const res = e.results[i];
        if (res.isFinal) finalText += res[0].transcript;
        else interim += res[0].transcript;
      }
      const live = (finalText || interim || '').trim();
      speakingPractice.liveTextEl.textContent = live;

      const pct = similarityPercent(live, target);
      speakingPractice.progressEl.value = pct;
      speakingPractice.scoreEl.textContent = pct + '%';

      if (pct >= speakingPractice.min && finalText) {
        speakingPractice.statusEl.textContent = 'Great! ✅';
        try { rec.abort(); } catch {}
        // Prepare next phrase safely
        safeAdvanceSpeakingPractice(myToken);
      }
    };
    rec.onerror = () => {
      if (!speakingPractice.active) return;
      if (myToken !== phraseSessionId) return;
      // Keep listening; status note
      speakingPractice.statusEl.textContent = 'Listening…';
    };
    rec.onend = () => {
      // If ended unexpectedly while active and token still valid, attempt to restart
      if (speakingPractice.active && myToken === phraseSessionId) {
        try { rec.start(); } catch {}
      }
    };

    try { rec.start(); } catch {}
  }

  async function safeAdvanceSpeakingPractice(prevToken) {
    // Cancel all previous activities, increment session, then proceed
    try { speechSynthesis.cancel(); } catch {}
    if (speakingPractice.rec) {
      try { speakingPractice.rec.abort(); } catch {}
      speakingPractice.rec = null;
    }
    const newToken = ++phraseSessionId;
    if (!speakingPractice.active) return;
    // Move to next phrase: select + speak once, await speak, then listen again
    await selectAndShowRandomRow({ speak: true });
    if (!speakingPractice.active) return;
    // Restart recognition for the new target
    await startSpeakingPracticeCycleOnly();
  }

  async function startSpeakingPracticeCycleOnly() {
    // Start listening for current phrase without triggering TTS again
    const target = (parsedRows[currentIndex] || {})[speakingPractice.lang] || '';
    const myToken = phraseSessionId;

    if (speakingPractice.rec) {
      try { speakingPractice.rec.abort(); } catch {}
      speakingPractice.rec = null;
    }
    const rec = createRecognition(speakingPractice.lang);
    speakingPractice.rec = rec;
    if (!rec) {
      speakingPractice.statusEl.textContent = 'Speech recognition not supported in this browser.';
      speakingPractice.active = false;
      return;
    }

    speakingPractice.liveTextEl.textContent = '';
    speakingPractice.progressEl.value = 0;
    speakingPractice.scoreEl.textContent = '0%';
    speakingPractice.statusEl.textContent = 'Listening…';

    rec.onresult = (e) => {
      if (!speakingPractice.active) return;
      if (myToken !== phraseSessionId) return;
      let interim = '';
      let finalText = '';
      for (let i = e.resultIndex; i < e.results.length; i++) {
        const res = e.results[i];
        if (res.isFinal) finalText += res[0].transcript;
        else interim += res[0].transcript;
      }
      const live = (finalText || interim || '').trim();
      speakingPractice.liveTextEl.textContent = live;

      const pct = similarityPercent(live, target);
      speakingPractice.progressEl.value = pct;
      speakingPractice.scoreEl.textContent = pct + '%';

      if (pct >= speakingPractice.min && finalText) {
        speakingPractice.statusEl.textContent = 'Great! ✅';
        try { rec.abort(); } catch {}
        safeAdvanceSpeakingPractice(myToken);
      }
    };
    rec.onerror = () => {
      if (!speakingPractice.active) return;
      if (myToken !== phraseSessionId) return;
      speakingPractice.statusEl.textContent = 'Listening…';
    };
    rec.onend = () => {
      if (speakingPractice.active && myToken === phraseSessionId) {
        try { rec.start(); } catch {}
      }
    };
    try { rec.start(); } catch {}
  }

  function stopSpeakingPractice() {
    speakingPractice.active = false;
    if (speakingPractice.rec) {
      try { speakingPractice.rec.abort(); } catch {}
      speakingPractice.rec = null;
    }
    try { speechSynthesis.cancel(); } catch {}
    if (speakingPractice.statusEl) speakingPractice.statusEl.textContent = 'Stopped';
  }

  // --- Writing Practice Flow ---
  async function startWritingPractice() {
    if (writingPractice.active) return;
    writingPractice.active = true;
    writingPractice.statusEl.textContent = 'Starting…';
    writingPractice.lang = (els.modeContent.querySelector('#wr-lang')?.value) || 'es';

    // Select and speak once
    await selectAndShowRandomRow({ speak: true });
    updateCurrentWriteTarget();
    writingPractice.statusEl.textContent = 'Type what you hear…';

    // Attach oninput handler referencing mutable target
    const input = writingPractice.inputEl;
    input.value = '';
    input.disabled = false;

    const onInput = async (e) => {
      if (!writingPractice.active || writingPractice.writingBusy) return;
      const user = normalizeForCompare(e.target.value);
      const target = normalizeForCompare(writingPractice.currentWriteTarget);
      if (user && user === target) {
        writingPractice.writingBusy = true;
        // Advance to next phrase safely; ensure single playback
        try { speechSynthesis.cancel(); } catch {}
        await selectAndShowRandomRow({ speak: true });
        updateCurrentWriteTarget();
        e.target.value = '';
        writingPractice.writingBusy = false;
      }
    };
    // Store handler so we can disable/enable without stale closure
    input.oninput = onInput;
  }

  function stopWritingPractice() {
    writingPractice.active = false;
    if (writingPractice.inputEl) {
      writingPractice.inputEl.oninput = null;
      writingPractice.inputEl.disabled = true;
    }
    try { speechSynthesis.cancel(); } catch {}
    if (writingPractice.statusEl) writingPractice.statusEl.textContent = 'Stopped';
  }

  function updateCurrentWriteTarget() {
    const row = parsedRows[currentIndex] || {};
    const k = writingPractice.lang;
    writingPractice.currentWriteTarget = row[k] || '';
  }

  // --- Voices population ---
  function populateVoices() {
    const voices = speechSynthesis.getVoices();
    for (const k of langs) {
      const sel = els.voices[k];
      const prev = sel.value;
      sel.innerHTML = '';
      const group = voices
        .filter(v => v.lang && v.lang.toLowerCase().startsWith(k))
        .concat(voices.filter(v => !(v.lang && v.lang.toLowerCase().startsWith(k)))); // fallback at end
      for (const v of group) {
        const opt = document.createElement('option');
        opt.value = v.name;
        opt.textContent = `${v.name} (${v.lang || '??'})`;
        sel.appendChild(opt);
      }
      // Try auto-select a sensible default
      const guess = voices.find(v => v.lang && langMeta[k].localeGuess.some(gl => v.lang.startsWith(gl)));
      if (guess) sel.value = guess.name;
      if (!sel.value && sel.options.length) sel.selectedIndex = 0;
      if (prev && [...sel.options].some(o => o.value === prev)) sel.value = prev;
    }
  }

  // --- Predefined sets discovery & loading ---
  async function populatePredefinedList() {
  const sel = els.predefinedSelect;
  sel.innerHTML = ''; // Limpiar opciones previas

  try {
    // Intento local
    const res = await fetch('./predefined_phrases/');
    const text = await res.text();
    const tmp = document.createElement('div');
    tmp.innerHTML = text;
    const links = [...tmp.querySelectorAll('a[href$=".csv"], a[href$=".txt"]')];
    const names = links.map(a => (a.textContent || '').trim()).filter(Boolean);
    if (names.length === 0) throw new Error('No se encontraron archivos válidos en el servidor local.');
    for (const n of names) {
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    }
  } catch (error) {
    console.warn('Fallo la carga local:', error.message || error.toString());
    await fallbackToGithub();
  }

  async function fallbackToGithub() {
    try {
      const user = "haiver77";       // ejemplo: "johnmalagon"
      const repo = "language_learning";   // ejemplo: "mi-web"
      const branch = "main";           // o "master" según tu repo
      const path = "predefined_phrases"; 

      const githubApiUrl = `https://api.github.com/repos/${user}/${repo}/contents/${path}?ref=${branch}`;
      const res = await fetch(githubApiUrl);
      const files = await res.json();
      if (!Array.isArray(files)) throw new Error('Respuesta inesperada de GitHub');

      const validFiles = files
        .filter(f => f.name.endsWith('.csv') || f.name.endsWith('.txt'))
        .map(f => f.name);

      if (validFiles.length === 0) throw new Error('No se encontraron archivos válidos en GitHub.');

      for (const name of validFiles) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      }
    } catch (err) {
      alert('No se pudo cargar la lista de frases desde GitHub: ' + (err.message || err.toString()));
    }
  }
}


  async function loadSelectedPredefined() {
    const name = els.predefinedSelect.value;
    if (!name) return;
    try {
      const res = await fetch(`./predefined_phrases/${encodeURIComponent(name)}`);
      const text = await res.text();
      els.csvBox.value = text.trim();
      ensureParsed();
      if (parsedRows.length) {
        await selectAndShowRandomRow({ speak: false });
      }
    } catch {
      // ignore
    }
  }

  // --- Event wiring ---
  function bindEvents() {
    // Random button (global)
    els.btnRandom.onclick = async () => { await selectAndShowRandomRow({ speak: true }); };

    // Mode switching
    els.modeSelect.onchange = () => {
      // Stop timers/practices on switch
      if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
      stopSpeakingPractice();
      stopWritingPractice();
      renderModePanel();
    };

    // Replay per language
    for (const k of langs) {
      els.replay[k].onclick = () => replayLanguage(k);
    }

    // Show/Hide languages
    for (const k of langs) {
      els.show[k].onchange = applyShowVisibility;
    }

    // Font size
    const applyFont = () => {
      const px = Math.max(14, Math.min(100, parseInt(els.fontRange.value || '26', 10)));
      document.documentElement.style.setProperty('--phrase-font', px + 'px');
      els.fontValue.textContent = px + ' px';
    };
    els.fontRange.oninput = applyFont;

    // Theme toggle
    els.themeToggle.onchange = () => {
      const isDark = els.themeToggle.checked;
      document.body.classList.toggle('theme-light', !isDark);
      document.body.classList.toggle('theme-dark', isDark);
    };

    // CSV changes
    els.csvBox.oninput = () => {
      ensureParsed();
    };

    // Predefined
    els.btnLoadPredefined.onclick = loadSelectedPredefined;

    // File input
    els.fileInput.onchange = async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      els.csvBox.value = text.trim();
      ensureParsed();
      await selectAndShowRandomRow({ speak: false });
    };

    // Voices ready
    if ('onvoiceschanged' in speechSynthesis) {
      speechSynthesis.onvoiceschanged = () => populateVoices();
    }
  }

  // --- Init sample data ---
  function loadSamplePhrases() {
    const sample = [
      'Hola;Hello;Ciao;Olá',
      'Buenos días;Good morning;Buongiorno;Bom dia',
      '¿Cómo estás?;How are you?;Come stai?;Como você está?',
      'Gracias;Thank you;Grazie;Obrigado',
      'Por favor;Please;Per favore;Por favor',
      'Lo siento;Sorry;Mi dispiace;Desculpe',
      '¿Dónde está el baño?;Where is the bathroom?;Dov\'è il bagno?;Onde fica o banheiro?',
      'Me gusta aprender idiomas;I like learning languages;Mi piace imparare le lingue;Gosto de aprender línguas',
      '¿Cuánto cuesta?;How much is it?;Quanto costa?;Quanto custa?',
      'Hasta luego;See you later;A dopo;Até mais'
    ].join('\n');
    els.csvBox.value = sample;
    ensureParsed();
  }

  // --- Bootstrap ---
  function init() {
    loadSamplePhrases();
    renderModePanel();
    bindEvents();
    applyShowVisibility();
    populateVoices();
    populatePredefinedList();

    // Initial phrase display (silent) so UI isn't empty
    selectAndShowRandomRow({ speak: false });

    // Defaults: dark theme, font slider reflect
    els.themeToggle.checked = true;
    els.fontRange.value = 26;
    els.fontValue.textContent = '26 px';
  }

  // Expose minimal for debugging (optional)
  window._trainer = { state: () => ({ currentIndex, phraseSessionId, parsedRowsCount: parsedRows.length }) };

  init();
})();
</script>
</body>
</html>
